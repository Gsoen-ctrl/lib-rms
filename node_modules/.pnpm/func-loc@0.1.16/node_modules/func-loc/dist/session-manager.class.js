"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
const inspector_1 = require("inspector");
const util_1 = require("util");
const uuid_1 = require("uuid");
const cache_amanger_class_1 = require("./cache-amanger.class");
const deffered_class_1 = require("./deffered.class");
const mapper_class_1 = require("./mapper.class");
const PREFIX = '__functionLocation__';
class SessionManager {
    constructor() {
        this.cache = new cache_amanger_class_1.CacheManager();
        this.scripts = {};
    }
    async clean() {
        if (!this.session) {
            return true;
        }
        await this.post$('Runtime.releaseObjectGroup', {
            objectGroup: PREFIX,
        });
        this.session.disconnect();
        delete global[PREFIX];
        this.session = undefined;
        this.cache.clear();
        return true;
    }
    async locate(fn, opts) {
        if (typeof fn !== 'function') {
            throw new Error('You are allowed only to reference functions.');
        }
        // Look from the function inside the cache array and return it if it does exist.
        const fromCache = await this.cache.get(fn);
        const isMap = opts && opts.sourceMap;
        if (fromCache) {
            return await fromCache.location.promise;
        }
        const deferred = new deffered_class_1.Deferred();
        // Push a deffered location into the cache
        this.cache.add({ ref: fn, location: deferred });
        // Create a function location object to put referencies into it
        // So that we can easilly access to them
        if (typeof global[PREFIX] === 'undefined') {
            global[PREFIX] = {};
        }
        // Create a reference of the function inside the global object
        const uuid = uuid_1.v4();
        global[PREFIX][uuid] = fn;
        // Create an inspector session an enable the debugger inside it
        if (!this.session) {
            this.session = new inspector_1.Session();
            this.post$ = util_1.promisify(this.session.post).bind(this.session);
            this.session.connect();
            this.session.on('Debugger.scriptParsed', (res) => {
                this.scripts[res.params.scriptId] = res.params;
            });
            await this.post$('Debugger.enable');
        }
        // Evaluate the expression
        const evaluated = await this.post$('Runtime.evaluate', {
            expression: `global['${PREFIX}']['${uuid}']`,
            objectGroup: PREFIX,
        });
        // Get the function properties
        const properties = await this.post$('Runtime.getProperties', {
            objectId: evaluated.result.objectId,
        });
        const location = properties.internalProperties.find((prop) => prop.name === '[[FunctionLocation]]');
        const script = this.scripts[location.value.value.scriptId];
        let source = script.url;
        const sourceMapUrl = script.sourceMapURL;
        // Normalize the source uri to ensure consistent result
        if (!source.startsWith('file://')) {
            source = `file://${source}`;
        }
        // Construct the result object
        let result = {
            column: location.value.value.columnNumber + 1,
            line: location.value.value.lineNumber + 1,
            path: source.substr(7),
            source,
        };
        if (isMap) {
            try {
                const res = await mapper_class_1.SourceMapper.map(result, sourceMapUrl);
                if (res) {
                    result = res;
                }
            }
            catch (e) {
                // Do nothing
            }
        }
        // Resolve the defered variable
        deferred.resolve(result);
        // return the result
        return result;
    }
}
exports.SessionManager = SessionManager;
//# sourceMappingURL=session-manager.class.js.map