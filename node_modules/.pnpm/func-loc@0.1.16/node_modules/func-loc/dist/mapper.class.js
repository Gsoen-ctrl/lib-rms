"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceMapper = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const source_map_1 = require("source-map");
const util_1 = require("util");
const data_urls_1 = __importDefault(require("data-urls"));
const deffered_class_1 = require("./deffered.class");
const readFile$ = util_1.promisify(fs_1.readFile);
const REGEX = /\/\/# sourceMappingURL=(.*\.map)$/m;
require.extensions['.map'] = require.extensions['.json'];
const cache = {};
class SourceMapper {
    static normalizePath(p) {
        let pathName = path_1.resolve(p).replace(/\\/g, '/');
        // Windows drive letter must be prefixed with a slash
        if (pathName[0] !== '/') {
            pathName = `/${pathName}`;
        }
        return pathName;
    }
    static async map(location, sourceMapUrl) {
        const { consumer, sourceMapPath } = await this.getSrcMap(location, sourceMapUrl);
        const mappedLocation = consumer.originalPositionFor({
            column: location.column,
            line: location.line,
        });
        if (!mappedLocation || !mappedLocation.column || !mappedLocation.line) {
            return location;
        }
        const path = this.normalizePath(path_1.resolve(sourceMapPath, '..', mappedLocation.source));
        return {
            column: mappedLocation.column,
            line: mappedLocation.line,
            origin: location,
            path,
            source: `file://${path}`,
        };
    }
    static getPlatformPath(path) {
        const exec = /^\/(\w*):(.*)/.exec(path);
        return /^win/.test(process.platform) && exec ? `${exec[1]}:\\${exec[2].replace(/\//g, '\\')}` : path;
    }
    static async getSrcMap(location, sourceMapUrl) {
        let { path } = location;
        path = this.getPlatformPath(path);
        if (cache[path]) {
            const fileMap = await cache[path].promise;
            return fileMap;
        }
        const deferred = new deffered_class_1.Deferred();
        cache[path] = deferred;
        const content = await readFile$(path, { encoding: 'utf8' });
        const exec = REGEX.exec(content);
        const result = { content };
        if (exec) {
            result.sourceMapPath = path_1.resolve(path, '..', exec[1]);
            result.sourceMap = require(result.sourceMapPath);
            result.consumer = await new source_map_1.SourceMapConsumer(result.sourceMap);
        }
        else if (sourceMapUrl) {
            const parsedSourceMapUrl = data_urls_1.default(sourceMapUrl);
            if (parsedSourceMapUrl && parsedSourceMapUrl.body) {
                result.sourceMap = JSON.parse(parsedSourceMapUrl.body.toString());
                result.consumer = await new source_map_1.SourceMapConsumer(result.sourceMap);
            }
        }
        deferred.resolve(result);
        return result;
    }
}
exports.SourceMapper = SourceMapper;
//# sourceMappingURL=mapper.class.js.map