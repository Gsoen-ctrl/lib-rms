"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRPCGenerator = void 0;
const tslib_1 = require("tslib");
const path = require("node:path");
const common_1 = require("@nestjs/common");
const ts_morph_1 = require("ts-morph");
const file_util_1 = require("../utils/file.util");
const router_generator_1 = require("./router.generator");
const middleware_generator_1 = require("./middleware.generator");
const context_generator_1 = require("./context.generator");
const router_factory_1 = require("../factories/router.factory");
const middleware_factory_1 = require("../factories/middleware.factory");
const procedure_factory_1 = require("../factories/procedure.factory");
let TRPCGenerator = class TRPCGenerator {
    constructor() {
        this.APP_ROUTER_OUTPUT_FILE = 'server.ts';
        this.HELPER_TYPES_OUTPUT_FILE = 'index.ts';
        this.HELPER_TYPES_OUTPUT_PATH = path.join(__dirname, 'types');
    }
    onModuleInit() {
        const defaultCompilerOptions = {
            target: ts_morph_1.ScriptTarget.ES2019,
            module: ts_morph_1.ModuleKind.CommonJS,
            emitDecoratorMetadata: true,
            experimentalDecorators: true,
            esModuleInterop: true,
        };
        this.project = new ts_morph_1.Project({ compilerOptions: defaultCompilerOptions });
    }
    async generateSchemaFile(outputDirPath) {
        try {
            const routers = this.routerFactory.getRouters();
            const mappedRoutesAndProcedures = routers.map((route) => {
                const { instance, name, alias } = route;
                const prototype = Object.getPrototypeOf(instance);
                const procedures = this.procedureFactory.getProcedures(instance, prototype);
                return { name, alias, instance: { ...route }, procedures };
            });
            const appRouterSourceFile = this.project.createSourceFile(path.resolve(outputDirPath, this.APP_ROUTER_OUTPUT_FILE), undefined, { overwrite: true });
            (0, file_util_1.generateStaticDeclaration)(appRouterSourceFile);
            const routersMetadata = await this.serializerHandler.serializeRouters(mappedRoutesAndProcedures, this.project);
            const routersStringDeclarations = this.serializerHandler.generateRoutersStringFromMetadata(routersMetadata);
            appRouterSourceFile.addStatements(/* ts */ `
        const appRouter = t.router({${routersStringDeclarations}});
        export type AppRouter = typeof appRouter;
      `);
            await (0, file_util_1.saveOrOverrideFile)(appRouterSourceFile);
            this.consoleLogger.log(`AppRouter has been updated successfully at "${outputDirPath}/${this.APP_ROUTER_OUTPUT_FILE}".`, 'TRPC Generator');
        }
        catch (e) {
            this.consoleLogger.warn('TRPC Generator encountered an error.', e);
        }
    }
    async generateHelpersFile(context) {
        try {
            const middlewares = this.middlewareFactory.getMiddlewares();
            const helperTypesSourceFile = this.project.createSourceFile(path.resolve(this.HELPER_TYPES_OUTPUT_PATH, this.HELPER_TYPES_OUTPUT_FILE), undefined, { overwrite: true });
            if (context != null) {
                const contextType = await this.contextHandler.getContextInterface(context, this.project);
                helperTypesSourceFile.addTypeAlias({
                    isExported: true,
                    name: 'Context',
                    type: contextType ?? '{}',
                });
            }
            for (const middleware of middlewares) {
                const middlewareInterface = await this.middlewareHandler.getMiddlewareInterface(middleware, this.project);
                if (middlewareInterface != null) {
                    helperTypesSourceFile.addInterface({
                        isExported: true,
                        name: `${middlewareInterface.name}Context`,
                        extends: ['Context'],
                        properties: middlewareInterface.properties,
                    });
                }
            }
            await (0, file_util_1.saveOrOverrideFile)(helperTypesSourceFile);
            this.consoleLogger.log(`Helper types has been updated successfully at "nestjs-trpc/types".`, 'TRPC Generator');
        }
        catch (e) {
            this.consoleLogger.warn('TRPC Generator encountered an error.', e);
        }
    }
};
exports.TRPCGenerator = TRPCGenerator;
tslib_1.__decorate([
    (0, common_1.Inject)(common_1.ConsoleLogger),
    tslib_1.__metadata("design:type", common_1.ConsoleLogger)
], TRPCGenerator.prototype, "consoleLogger", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(middleware_generator_1.MiddlewareGenerator),
    tslib_1.__metadata("design:type", middleware_generator_1.MiddlewareGenerator)
], TRPCGenerator.prototype, "middlewareHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(context_generator_1.ContextGenerator),
    tslib_1.__metadata("design:type", context_generator_1.ContextGenerator)
], TRPCGenerator.prototype, "contextHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(router_generator_1.RouterGenerator),
    tslib_1.__metadata("design:type", router_generator_1.RouterGenerator)
], TRPCGenerator.prototype, "serializerHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(router_factory_1.RouterFactory),
    tslib_1.__metadata("design:type", router_factory_1.RouterFactory)
], TRPCGenerator.prototype, "routerFactory", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(procedure_factory_1.ProcedureFactory),
    tslib_1.__metadata("design:type", procedure_factory_1.ProcedureFactory)
], TRPCGenerator.prototype, "procedureFactory", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(middleware_factory_1.MiddlewareFactory),
    tslib_1.__metadata("design:type", middleware_factory_1.MiddlewareFactory)
], TRPCGenerator.prototype, "middlewareFactory", void 0);
exports.TRPCGenerator = TRPCGenerator = tslib_1.__decorate([
    (0, common_1.Injectable)()
], TRPCGenerator);
