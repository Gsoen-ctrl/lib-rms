"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterGenerator = void 0;
const tslib_1 = require("tslib");
const func_loc_1 = require("func-loc");
const decorator_generator_1 = require("./decorator.generator");
const type_util_1 = require("../utils/type.util");
const common_1 = require("@nestjs/common");
const lodash_1 = require("lodash");
let RouterGenerator = class RouterGenerator {
    async serializeRouters(routers, project) {
        return await Promise.all(routers.map(async (router) => {
            const proceduresMetadata = await Promise.all(router.procedures.map(async (procedure) => await this.serializeRouterProcedures(procedure, router.name, project)));
            return {
                name: router.name,
                alias: router.alias,
                procedures: proceduresMetadata,
            };
        }));
    }
    async serializeRouterProcedures(procedure, routerName, project) {
        const location = await (0, func_loc_1.locate)(procedure.implementation, {
            sourceMap: true,
        });
        const sourceFile = project.addSourceFileAtPath(location.path);
        const classDeclaration = sourceFile.getClass(routerName);
        if (!classDeclaration) {
            throw new Error(`Could not find router ${routerName} class declaration.`);
        }
        const methodDeclaration = classDeclaration.getMethod(procedure.name);
        if (!methodDeclaration) {
            throw new Error(`Could not find ${routerName}, method declarations.`);
        }
        const decorators = methodDeclaration.getDecorators();
        if (!decorators) {
            throw new Error(`could not find ${methodDeclaration.getName()}, method decorators.`);
        }
        const serializedDecorators = this.decoratorHandler.serializeProcedureDecorators(decorators, sourceFile, project);
        return {
            name: procedure.name,
            decorators: serializedDecorators,
        };
    }
    generateRoutersStringFromMetadata(routers) {
        return routers
            .map((router) => {
            const { name, procedures, alias } = router;
            return `${alias ?? (0, lodash_1.camelCase)(name)}: t.router({ ${procedures
                .map(type_util_1.generateProcedureString)
                .join(',\n')} })`;
        })
            .join(',\n');
    }
};
exports.RouterGenerator = RouterGenerator;
tslib_1.__decorate([
    (0, common_1.Inject)(decorator_generator_1.DecoratorGenerator),
    tslib_1.__metadata("design:type", decorator_generator_1.DecoratorGenerator)
], RouterGenerator.prototype, "decoratorHandler", void 0);
exports.RouterGenerator = RouterGenerator = tslib_1.__decorate([
    (0, common_1.Injectable)()
], RouterGenerator);
