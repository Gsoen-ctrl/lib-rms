"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticGenerator = void 0;
const tslib_1 = require("tslib");
const ts_morph_1 = require("ts-morph");
const common_1 = require("@nestjs/common");
const path = tslib_1.__importStar(require("node:path"));
let StaticGenerator = class StaticGenerator {
    generateStaticDeclaration(sourceFile) {
        sourceFile.addImportDeclaration({
            kind: ts_morph_1.StructureKind.ImportDeclaration,
            moduleSpecifier: '@trpc/server',
            namedImports: ['initTRPC'],
        });
        sourceFile.addImportDeclaration({
            kind: ts_morph_1.StructureKind.ImportDeclaration,
            moduleSpecifier: 'zod',
            namedImports: ['z'],
        });
        sourceFile.addVariableStatements([
            {
                declarationKind: ts_morph_1.VariableDeclarationKind.Const,
                declarations: [{ name: 't', initializer: 'initTRPC.create()' }],
            },
            {
                declarationKind: ts_morph_1.VariableDeclarationKind.Const,
                declarations: [{ name: 'publicProcedure', initializer: 't.procedure' }],
            },
        ]);
    }
    addSchemaImports(sourceFile, schemaImportNames, importsMap) {
        const importDeclarations = [];
        for (const schemaImportName of schemaImportNames) {
            for (const [importMapKey, importMapMetadata] of importsMap.entries()) {
                if (schemaImportName == null || importMapKey !== schemaImportName) {
                    continue;
                }
                const relativePath = path.relative(path.dirname(sourceFile.getFilePath()), importMapMetadata.sourceFile.getFilePath().replace(/\.ts$/, ''));
                importDeclarations.push({
                    kind: ts_morph_1.StructureKind.ImportDeclaration,
                    moduleSpecifier: relativePath.startsWith('.')
                        ? relativePath
                        : `./${relativePath}`,
                    namedImports: [schemaImportName],
                });
            }
        }
        sourceFile.addImportDeclarations(importDeclarations);
    }
    findCtxOutProperty(type) {
        const typeText = type.getText();
        const ctxOutMatch = typeText.match(/_ctx_out:\s*{([^}]*)}/);
        return ctxOutMatch ? ctxOutMatch[1].trim() : undefined;
    }
};
exports.StaticGenerator = StaticGenerator;
exports.StaticGenerator = StaticGenerator = tslib_1.__decorate([
    (0, common_1.Injectable)()
], StaticGenerator);
//# sourceMappingURL=static.generator.js.map