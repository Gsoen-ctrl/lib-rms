"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiddlewareGenerator = void 0;
const tslib_1 = require("tslib");
const ts_morph_1 = require("ts-morph");
const common_1 = require("@nestjs/common");
let MiddlewareGenerator = class MiddlewareGenerator {
    async getMiddlewareInterface(routerFilePath, middleware, project) {
        const className = middleware.name;
        if (!className) {
            return null;
        }
        const middlewareInstance = new middleware();
        if (typeof middlewareInstance.use !== 'function') {
            return null;
        }
        const contextSourceFile = project.addSourceFileAtPath(routerFilePath);
        const classDeclaration = this.getClassDeclaration(contextSourceFile, middleware.name);
        if (!classDeclaration) {
            return null;
        }
        const useMethod = classDeclaration.getMethod('use');
        if (!useMethod) {
            return null;
        }
        const ctxType = this.extractCtxTypeFromUseMethod(useMethod);
        if (!ctxType) {
            return null;
        }
        return {
            name: className,
            properties: this.typeToProperties(ctxType),
        };
    }
    extractCtxTypeFromUseMethod(useMethod) {
        const body = useMethod.getBody();
        if (!body)
            return null;
        // Find the call to opts.next()
        const nextCall = body
            .getDescendantsOfKind(ts_morph_1.SyntaxKind.CallExpression)
            .find((call) => {
            const expression = call.getExpression();
            return (ts_morph_1.Node.isPropertyAccessExpression(expression) &&
                expression.getName() === 'next' &&
                ts_morph_1.Node.isIdentifier(expression.getExpression()) &&
                expression.getExpression().getText() === 'opts');
        });
        if (!nextCall)
            return null;
        // Get the argument passed to opts.next()
        const nextArg = nextCall.getArguments()[0];
        if (!ts_morph_1.Node.isObjectLiteralExpression(nextArg))
            return null;
        // Find the 'ctx' property in the argument
        const ctxProperty = nextArg
            .getProperties()
            .find((prop) => ts_morph_1.Node.isPropertyAssignment(prop) && prop.getName() === 'ctx');
        if (!ts_morph_1.Node.isPropertyAssignment(ctxProperty))
            return null;
        // Get the type of the 'ctx' property value
        return ctxProperty.getInitializer()?.getType() || null;
    }
    getClassDeclaration(sourceFile, className) {
        const classDeclaration = sourceFile.getClass(className);
        if (classDeclaration) {
            return classDeclaration;
        }
        return undefined;
    }
    typeToProperties(type) {
        const properties = [];
        if (type.isObject()) {
            type.getProperties().forEach((prop) => {
                const propValueDeclaration = prop.getValueDeclaration();
                if (propValueDeclaration != null) {
                    properties.push({
                        name: prop.getName(),
                        type: prop.getTypeAtLocation(propValueDeclaration).getText(),
                    });
                }
            });
        }
        return properties;
    }
};
exports.MiddlewareGenerator = MiddlewareGenerator;
exports.MiddlewareGenerator = MiddlewareGenerator = tslib_1.__decorate([
    (0, common_1.Injectable)()
], MiddlewareGenerator);
//# sourceMappingURL=middleware.generator.js.map