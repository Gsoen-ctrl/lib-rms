"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRPCGenerator = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("node:path"));
const common_1 = require("@nestjs/common");
const ts_morph_1 = require("ts-morph");
const ts_morph_util_1 = require("../utils/ts-morph.util");
const router_generator_1 = require("./router.generator");
const middleware_generator_1 = require("./middleware.generator");
const context_generator_1 = require("./context.generator");
const router_factory_1 = require("../factories/router.factory");
const middleware_factory_1 = require("../factories/middleware.factory");
const procedure_factory_1 = require("../factories/procedure.factory");
const trpc_constants_1 = require("../trpc.constants");
const static_generator_1 = require("./static.generator");
const imports_scanner_1 = require("../scanners/imports.scanner");
const generator_constants_1 = require("./generator.constants");
const process = tslib_1.__importStar(require("node:process"));
let TRPCGenerator = class TRPCGenerator {
    constructor() {
        this.HELPER_TYPES_OUTPUT_FILE = 'index.ts';
        this.HELPER_TYPES_OUTPUT_PATH = path.join(__dirname, 'types');
    }
    onModuleInit() {
        this.rootModuleImportsMap = this.buildRootImportsMap();
    }
    async generateSchemaFile(schemaImports) {
        try {
            const routers = this.routerFactory.getRouters();
            const mappedRoutesAndProcedures = routers.map((route) => {
                const { instance, name, alias, path } = route;
                const prototype = Object.getPrototypeOf(instance);
                const procedures = this.procedureFactory.getProcedures(instance, prototype);
                return { name, path, alias, instance: { ...route }, procedures };
            });
            this.staticGenerator.generateStaticDeclaration(this.appRouterSourceFile);
            if (schemaImports != null && schemaImports.length > 0) {
                const schemaImportNames = schemaImports.map((schemaImport) => schemaImport.name);
                this.staticGenerator.addSchemaImports(this.appRouterSourceFile, schemaImportNames, this.rootModuleImportsMap);
            }
            const routersMetadata = this.serializerHandler.serializeRouters(mappedRoutesAndProcedures, this.project);
            const routersStringDeclarations = this.serializerHandler.generateRoutersStringFromMetadata(routersMetadata);
            this.appRouterSourceFile.addStatements(/* ts */ `
        const appRouter = t.router({${routersStringDeclarations}});
        export type AppRouter = typeof appRouter;
      `);
            await (0, ts_morph_util_1.saveOrOverrideFile)(this.appRouterSourceFile);
            this.consoleLogger.log(`AppRouter has been updated successfully at "./${path.relative(process.cwd(), this.appRouterSourceFile.getFilePath())}".`, 'TRPC Generator');
        }
        catch (error) {
            this.consoleLogger.warn('TRPC Generator encountered an error.', error);
        }
    }
    async generateHelpersFile(context) {
        try {
            const middlewares = this.middlewareFactory.getMiddlewares();
            const helperTypesSourceFile = this.project.createSourceFile(path.resolve(this.HELPER_TYPES_OUTPUT_PATH, this.HELPER_TYPES_OUTPUT_FILE), undefined, { overwrite: true });
            if (context != null) {
                const contextImport = this.rootModuleImportsMap.get(context.name);
                if (contextImport == null) {
                    throw new Error('Could not find context import declaration.');
                }
                const contextType = await this.contextHandler.getContextInterface(contextImport.sourceFile, context);
                helperTypesSourceFile.addTypeAlias({
                    isExported: true,
                    name: 'Context',
                    type: contextType ?? '{}',
                });
            }
            for (const middleware of middlewares) {
                const middlewareInterface = await this.middlewareHandler.getMiddlewareInterface(middleware.path, middleware.instance, this.project);
                if (middlewareInterface != null) {
                    helperTypesSourceFile.addInterface({
                        isExported: true,
                        name: `${middlewareInterface.name}Context`,
                        extends: ['Context'],
                        properties: middlewareInterface.properties,
                    });
                }
            }
            await (0, ts_morph_util_1.saveOrOverrideFile)(helperTypesSourceFile);
            this.consoleLogger.log(`Helper types has been updated successfully at "nestjs-trpc/types".`, 'TRPC Generator');
        }
        catch (e) {
            this.consoleLogger.warn('TRPC Generator encountered an error.', e);
        }
    }
    buildRootImportsMap() {
        const rootModuleSourceFile = this.project.addSourceFileAtPathIfExists(this.moduleCallerFilePath);
        if (rootModuleSourceFile == null) {
            throw new Error('Could not access root module file.');
        }
        return this.importsScanner.buildSourceFileImportsMap(rootModuleSourceFile, this.project);
    }
};
exports.TRPCGenerator = TRPCGenerator;
tslib_1.__decorate([
    (0, common_1.Inject)(trpc_constants_1.TRPC_MODULE_CALLER_FILE_PATH),
    tslib_1.__metadata("design:type", String)
], TRPCGenerator.prototype, "moduleCallerFilePath", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(generator_constants_1.TYPESCRIPT_PROJECT),
    tslib_1.__metadata("design:type", ts_morph_1.Project)
], TRPCGenerator.prototype, "project", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(generator_constants_1.TYPESCRIPT_APP_ROUTER_SOURCE_FILE),
    tslib_1.__metadata("design:type", ts_morph_1.SourceFile)
], TRPCGenerator.prototype, "appRouterSourceFile", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(common_1.ConsoleLogger),
    tslib_1.__metadata("design:type", common_1.ConsoleLogger)
], TRPCGenerator.prototype, "consoleLogger", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(static_generator_1.StaticGenerator),
    tslib_1.__metadata("design:type", static_generator_1.StaticGenerator)
], TRPCGenerator.prototype, "staticGenerator", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(middleware_generator_1.MiddlewareGenerator),
    tslib_1.__metadata("design:type", middleware_generator_1.MiddlewareGenerator)
], TRPCGenerator.prototype, "middlewareHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(context_generator_1.ContextGenerator),
    tslib_1.__metadata("design:type", context_generator_1.ContextGenerator)
], TRPCGenerator.prototype, "contextHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(router_generator_1.RouterGenerator),
    tslib_1.__metadata("design:type", router_generator_1.RouterGenerator)
], TRPCGenerator.prototype, "serializerHandler", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(router_factory_1.RouterFactory),
    tslib_1.__metadata("design:type", router_factory_1.RouterFactory)
], TRPCGenerator.prototype, "routerFactory", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(procedure_factory_1.ProcedureFactory),
    tslib_1.__metadata("design:type", procedure_factory_1.ProcedureFactory)
], TRPCGenerator.prototype, "procedureFactory", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(middleware_factory_1.MiddlewareFactory),
    tslib_1.__metadata("design:type", middleware_factory_1.MiddlewareFactory)
], TRPCGenerator.prototype, "middlewareFactory", void 0);
tslib_1.__decorate([
    (0, common_1.Inject)(imports_scanner_1.ImportsScanner),
    tslib_1.__metadata("design:type", imports_scanner_1.ImportsScanner)
], TRPCGenerator.prototype, "importsScanner", void 0);
exports.TRPCGenerator = TRPCGenerator = tslib_1.__decorate([
    (0, common_1.Injectable)()
], TRPCGenerator);
//# sourceMappingURL=trpc.generator.js.map